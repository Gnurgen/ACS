<review for-group="Rogild_Mads__stl152__group_698440">
  <exercises>

    <question1>
      <title>Serializability and Locking</title>
      <schedule1>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>YES</answer>
        <comment>
           Short description but correct.
        </comment>
      </schedule1>

      <schedule2>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>NO</answer>
        <comment>
            There is no argument in 1.2 detailing wether or 
            not either schedule could have been generated by strict 2PL.
            Because schedule 1 is not serialisable it cannot have been created by strict 2PL
            so an argument detailing where in the locking scheme we see the problem could have
            made us understand the reason for the locking scheme for the first schedule.
            Also, you have only used exclusive locks, also in cases where shared locks would have
            been enough.
        </comment>
      </schedule2>
    </question1>

    <question2>
      <title>Optimistic Concurrency Control</title>
      <scenario1>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>YES</answer>
        <comment>
          The argument is a little difficult to follow. It would have been easier if
          instead of refering to the book, you wrote the intersects that failed.
        </comment>
      </scenario1>

      <scenario2>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>YES</answer>
        <comment>
        </comment>
      </scenario2>

      <scenario3>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>YES</answer>
        <comment>
        </comment>
      </scenario3>

    </question2>
  </exercises>

  <programming>

    <question1>
      <title>Description of implementation and tests</title>
      <q1a>
        <text>
          Does the solution contain a clear description of the approach
          used to achieve before-or-after atomicity?
        </text>
        <answer>NO</answer>
      </q1a>
      <q1b>
        <text>
           Provide comments on any aspects that you found unclear in the
           description of the approach to achieve before-or-after atomicity
        </text>
        <answer>
        You mention that your implementation is similar to how 2PL work, but your
        explanation describes how your locking implementation works, not how it assures before-or-after atomicity.
        Instead of implementing your own locking, you could have used an existing one, for example read/write locks
        from implementing the java.util.concurrent.locks.ReadWriteLock interface.  
        The problem with implementing the locks yourself is that even if you use the locks as one should in 2PL
        if the locks are not implemented correctly it still is not correct.
        In your implementation of locks it is possible for two threads to both take the write lock.
        Assume there are 2 threads in the queue in the spin lock, then the lock is released.
        One of the threads (lets call it t1) checks to see if the lock is free wich it is and procedes to take the
        lock, but before it takes it the JVM switches threads and the second thread (t2) makes the check. It also sees
        that the lock is free and takes it. Then t1 is switched back and takes the lock (it alredy made the check).
        We now have two threads that both have an exclusive write lock. 
        </answer>
      </q1b>
      <q1c>
        <text>
          Does the code include implementations of Tests 1 and 2 of the
          assignment description as well as of at least another two test
          cases?
        </text>
        <answer>YES</answer>
      </q1c>
      <q1d-i>
        <text>
          Is it tested that the final state resulting from concurrent
          execution
          is correct in that it respects invariants designed in the test?
        </text>
        <answer>NO</answer>
      </q1d-i>
      <q1d-ii>
        <text>
          Is it tested that intermediate reads of the state during concurrent
          execution respect invariants designed in the test, so that it is
          arguable that these intermediate states could be found in an
          equivalent serial schedule?
        </text>
        <answer>NO</answer>
      </q1d-ii>
      <q1e>
        <text>
          Provide comments on why you found that any portions of the test
          descriptions were unclear according to the criteria, and suggestions for
          improvement
        </text>
        <answer>
          It would have helped readability if you had written what method names corresponded to the different
          tests described in your report.
          When you run your test you don't join on the threads (and therefore don't know when they finished) in
          the test addBuy, and you can therefore not be assured you get the correct result.
          We could not run your test since the tests take an argument wich is not allowed in JUnit. Also we cannot see
          the number of iterations you ran the tests with, but if testWriteLock is any indication at 300 iterations,
          then this is way too low, as a thread can easily finish 300 iterations before the next thread is started, meaning
          there is never any concurrent threads.
          Your test of WriteLock is also wrong. First you only run 300 iterations which is not enough, when testing concurrency
          run at least 10.000 iterations, preferably 100.000+, and run many threads, like 1000. Second, the thread that writes
          only runs once, making it kind of useless to even start it as a thread. Thirdly, the check is not of what you think. 
          You check that the number of books in the bookstore i the same before and after, but you only add copies to those books.
          You should either have added more books and kept the current test, or added copies in many iterations and tested for the
          total number of copies. Currently the test can not fail, as it tests for the number of books being the same
          before and after the test, and none are added at any point during.
          Actually the third point applies to all tests, none can fail because all tests are of the number of books in the bookstore,
          but the tests add copies of existing books. Therefore the number of books can never change and the tests can never fail.
        </answer>
      </q1e>
    </question1>

    <question2>
      <title>Correctness argument for locking protocol</title>
      <q2a>
        <text>
          Is the variant of 2PL to which equivalence is being established in
          the correctness argument clearly identified (e.g., conservative, strict,
          conservative strict)?
        </text>
        <answer>NO</answer>
      </q2a>
      <q2b>
        <text>
          Is there a sound argumentation of why the steps in the locking
          protocol designed correspond to steps taken in the chosen variant
          of 2PL?
        </text>
        <answer>NO</answer>
      </q2b>
      <q2c>
        <text>
          Is there an argument for the need to take into account predicate
          reads, with appropriate justification?
        </text>
        <answer>YES</answer>
      </q2c>
      <q2d>
        <text>
          Is there an argument for the need to take into account predicate
          reads, with appropriate justification?
        </text>
        <answer>
          There is an argument for why predicate reads cannot occur.
        </answer>
      </q2d>
    </question2>

    <question3>
      <title>Deadlocks</title>
      <q3a>
        <text>
          Does the solution contain a correct argument for why deadlocks can
          occur in the locking protocol or why deadlocks cannot occur?
        </text>
        <answer>YES</answer>
      </q3a>
      <q3b>
        <text>
          Provide comments on how the argument provided with respect to
          deadlocks could be improved
        </text>
        <answer>
          Because of the simplicity of the locking implementation, the argument is fine. 
        </answer>
      </q3b>
    </question3>

    <question4>
      <title>Reflections on scalability</title>
      <q4a>
        <text>
          Is there a sound argument about the scalability limits of the
          concurrent implementation provided?
        </text>
        <answer>NO</answer>
      </q4a>
      <q4b>
        <text>
          Provide comments on how the reflections on scalability could be
          improved
        </text>
        <answer>
          The desription of the bottelneck is correct, but if you wanted to you could have thought
          about how a different locking implementation could have prevented this bottleneck.
          Also, you don't mention how your implementation would do if more hardware resources would be 
          provided in a single mashine or how it would work if it should be distrbuted over several mashines. 
        </answer>
      </q4b>
    </question4>

    <question5>
      <title>Argumentation on decisions made for performance</title>
      <q5a>
        <text>
          Is there a sound argument in the solution about the trade-off between
          locking overhead and concurrency?
        </text>
        <answer>YES</answer>
      </q5a>
      <q5b>
        <text>
          Provide comments on how the argument about performance trade-offs in
          the locking protocol could be improved
        </text>
        <answer>
         Your solution dosen't mention how much locking overhead is expected or how
         concurrency is affected with more clients. You mention that if a minimum of two clients where to
         request a read, it will be more concurrent but you don't mention if you assume this will happen a lot
         or almost never.
        </answer>
      </q5b>
    </question5>
  </programming>
</review>
